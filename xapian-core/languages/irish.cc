/* Generated by Snowball 2.0.0 - https://snowballstem.org/ */


#include <config.h>
#include <limits.h>
#include "irish.h"

static const symbol s_pool[] = {
#define s_0_0 0
'b', '\'',
#define s_0_1 s_0_2
#define s_0_2 2
'b', 'h', 'f',
#define s_0_3 5
'b', 'p',
#define s_0_4 7
'c', 'h',
#define s_0_5 s_0_6
#define s_0_6 9
'd', '\'', 'f', 'h',
#define s_0_7 13
'd', 'h',
#define s_0_8 15
'd', 't',
#define s_0_9 (s_0_6 + 2)
#define s_0_10 17
'g', 'c',
#define s_0_11 19
'g', 'h',
#define s_0_12 21
'h', '-',
#define s_0_13 23
'm', '\'',
#define s_0_14 25
'm', 'b',
#define s_0_15 27
'm', 'h',
#define s_0_16 29
'n', '-',
#define s_0_17 31
'n', 'd',
#define s_0_18 33
'n', 'g',
#define s_0_19 35
'p', 'h',
#define s_0_20 37
's', 'h',
#define s_0_21 39
't', '-',
#define s_0_22 41
't', 'h',
#define s_0_23 43
't', 's',
#define s_1_0 (s_1_1 + 1)
#define s_1_1 45
'a', 0xC3, 0xAD, 'o', 'c', 'h', 't', 'a',
#define s_1_2 (s_1_3 + 1)
#define s_1_3 53
'a', 'i', 'r', 'e',
#define s_1_4 (s_1_5 + 1)
#define s_1_5 57
'e', 'a', 'b', 'h',
#define s_1_6 (s_1_7 + 1)
#define s_1_7 61
'a', 'i', 'b', 'h',
#define s_1_8 (s_1_9 + 1)
#define s_1_9 65
'e', 'a', 'm', 'h',
#define s_1_10 (s_1_11 + 1)
#define s_1_11 69
'a', 'i', 'm', 'h',
#define s_1_12 s_1_0
#define s_1_13 s_1_1
#define s_1_14 (s_1_15 + 1)
#define s_1_15 73
'a', 'i', 'r', 0xC3, 0xAD,
#define s_2_0 78
0xC3, 0xB3, 'i', 'd', 'e', 'a', 'c', 'h', 'a',
#define s_2_1 87
'p', 'a', 't', 'a', 'c', 'h', 'a',
#define s_2_2 (s_2_3 + 3)
#define s_2_3 s_2_23
#define s_2_4 94
'e', 'a', 'c', 'h', 't', 'a',
#define s_2_5 s_2_24
#define s_2_6 100
'p', 'a', 'i', 't', 'e',
#define s_2_7 (s_2_0 + 5)
#define s_2_8 (s_2_0 + 4)
#define s_2_9 s_2_0
#define s_2_10 105
'g', 'i', 'n', 'e', 'a', 'c', 'h',
#define s_2_11 s_2_1
#define s_2_12 s_2_5
#define s_2_13 112
'p', 'a', 't', 'a', 'i', 'g', 'h',
#define s_2_14 119
0xC3, 0xB3, 'i', 'd', 'i', 'g', 'h',
#define s_2_15 (s_2_16 + 1)
#define s_2_16 126
'e', 'a', 'c', 'h', 't', 0xC3, 0xBA, 'i', 'l',
#define s_2_17 135
'g', 'i', 'n', 'e', 'a', 's',
#define s_2_18 141
'g', 'i', 'n', 'i', 's',
#define s_2_19 s_2_2
#define s_2_20 s_2_3
#define s_2_21 s_2_4
#define s_2_22 s_2_5
#define s_2_23 146
'a', 'r', 'c', 'a', 'c', 'h', 't', 'a', 0xC3, 0xAD,
#define s_2_24 156
'g', 'r', 'a', 'f', 'a', 0xC3, 0xAD, 'o', 'c', 'h', 't', 'a', 0xC3, 0xAD,
#define s_3_0 (s_3_1 + 1)
#define s_3_1 170
'a', 'i', 'm', 'i', 'd',
#define s_3_2 (s_3_3 + 1)
#define s_3_3 175
'a', 0xC3, 0xAD, 'm', 'i', 'd',
#define s_3_4 (s_3_5 + 1)
#define s_3_5 181
'e', 'a', 'd', 'h',
#define s_3_6 185
'f', 'a', 'i', 'd', 'h',
#define s_3_7 190
'f', 'i', 'd', 'h',
#define s_3_8 194
0xC3, 0xA1, 'i', 'l',
#define s_3_9 198
'a', 'i', 'n',
#define s_3_10 201
't', 'e', 'a', 'r',
#define s_3_11 205
't', 'a', 'r',
};


static const struct among a_0[24] =
{
/*  0 */ { 2, s_0_0, -1, 1},
/*  1 */ { 2, s_0_1, -1, 4},
/*  2 */ { 3, s_0_2, 1, 2},
/*  3 */ { 2, s_0_3, -1, 8},
/*  4 */ { 2, s_0_4, -1, 5},
/*  5 */ { 2, s_0_5, -1, 1},
/*  6 */ { 4, s_0_6, 5, 2},
/*  7 */ { 2, s_0_7, -1, 6},
/*  8 */ { 2, s_0_8, -1, 9},
/*  9 */ { 2, s_0_9, -1, 2},
/* 10 */ { 2, s_0_10, -1, 5},
/* 11 */ { 2, s_0_11, -1, 7},
/* 12 */ { 2, s_0_12, -1, 1},
/* 13 */ { 2, s_0_13, -1, 1},
/* 14 */ { 2, s_0_14, -1, 4},
/* 15 */ { 2, s_0_15, -1, 10},
/* 16 */ { 2, s_0_16, -1, 1},
/* 17 */ { 2, s_0_17, -1, 6},
/* 18 */ { 2, s_0_18, -1, 7},
/* 19 */ { 2, s_0_19, -1, 8},
/* 20 */ { 2, s_0_20, -1, 3},
/* 21 */ { 2, s_0_21, -1, 1},
/* 22 */ { 2, s_0_22, -1, 9},
/* 23 */ { 2, s_0_23, -1, 3}
};


static const struct among a_1[16] =
{
/*  0 */ { 7, s_1_0, -1, 1},
/*  1 */ { 8, s_1_1, 0, 1},
/*  2 */ { 3, s_1_2, -1, 2},
/*  3 */ { 4, s_1_3, 2, 2},
/*  4 */ { 3, s_1_4, -1, 1},
/*  5 */ { 4, s_1_5, 4, 1},
/*  6 */ { 3, s_1_6, -1, 1},
/*  7 */ { 4, s_1_7, 6, 1},
/*  8 */ { 3, s_1_8, -1, 1},
/*  9 */ { 4, s_1_9, 8, 1},
/* 10 */ { 3, s_1_10, -1, 1},
/* 11 */ { 4, s_1_11, 10, 1},
/* 12 */ { 6, s_1_12, -1, 1},
/* 13 */ { 7, s_1_13, 12, 1},
/* 14 */ { 4, s_1_14, -1, 2},
/* 15 */ { 5, s_1_15, 14, 2}
};


static const struct among a_2[25] =
{
/*  0 */ { 9, s_2_0, -1, 6},
/*  1 */ { 7, s_2_1, -1, 5},
/*  2 */ { 5, s_2_2, -1, 1},
/*  3 */ { 8, s_2_3, 2, 2},
/*  4 */ { 6, s_2_4, 2, 1},
/*  5 */ { 12, s_2_5, -1, 4},
/*  6 */ { 5, s_2_6, -1, 5},
/*  7 */ { 3, s_2_7, -1, 1},
/*  8 */ { 4, s_2_8, 7, 1},
/*  9 */ { 8, s_2_9, 8, 6},
/* 10 */ { 7, s_2_10, 8, 3},
/* 11 */ { 6, s_2_11, 7, 5},
/* 12 */ { 10, s_2_12, -1, 4},
/* 13 */ { 7, s_2_13, -1, 5},
/* 14 */ { 7, s_2_14, -1, 6},
/* 15 */ { 8, s_2_15, -1, 1},
/* 16 */ { 9, s_2_16, 15, 1},
/* 17 */ { 6, s_2_17, -1, 3},
/* 18 */ { 5, s_2_18, -1, 3},
/* 19 */ { 4, s_2_19, -1, 1},
/* 20 */ { 7, s_2_20, 19, 2},
/* 21 */ { 5, s_2_21, 19, 1},
/* 22 */ { 11, s_2_22, -1, 4},
/* 23 */ { 10, s_2_23, -1, 2},
/* 24 */ { 14, s_2_24, -1, 4}
};


static const struct among a_3[12] =
{
/*  0 */ { 4, s_3_0, -1, 1},
/*  1 */ { 5, s_3_1, 0, 1},
/*  2 */ { 5, s_3_2, -1, 1},
/*  3 */ { 6, s_3_3, 2, 1},
/*  4 */ { 3, s_3_4, -1, 2},
/*  5 */ { 4, s_3_5, 4, 2},
/*  6 */ { 5, s_3_6, -1, 1},
/*  7 */ { 4, s_3_7, -1, 1},
/*  8 */ { 4, s_3_8, -1, 2},
/*  9 */ { 3, s_3_9, -1, 2},
/* 10 */ { 4, s_3_10, -1, 2},
/* 11 */ { 3, s_3_11, -1, 2}
};

static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 2 };

static const symbol s_0[] = { 'f' };
static const symbol s_1[] = { 's' };
static const symbol s_2[] = { 'b' };
static const symbol s_3[] = { 'c' };
static const symbol s_4[] = { 'd' };
static const symbol s_5[] = { 'g' };
static const symbol s_6[] = { 'p' };
static const symbol s_7[] = { 't' };
static const symbol s_8[] = { 'm' };
static const symbol s_9[] = { 'a', 'r', 'c' };
static const symbol s_10[] = { 'g', 'i', 'n' };
static const symbol s_11[] = { 'g', 'r', 'a', 'f' };
static const symbol s_12[] = { 'p', 'a', 'i', 't', 'e' };
static const symbol s_13[] = { 0xC3, 0xB3, 'i', 'd' };

int Xapian::InternalStemIrish::r_mark_regions() {
    I_pV = l;
    I_p1 = l;
    I_p2 = l;
    {   int c1 = c;
        {   
            int ret = out_grouping_U(g_v, 97, 250, 1);
            if (ret < 0) goto lab0;
            c += ret;
        }
        I_pV = c;
    lab0:
        c = c1;
    }
    {   int c2 = c;
        {   
            int ret = out_grouping_U(g_v, 97, 250, 1);
            if (ret < 0) goto lab1;
            c += ret;
        }
        {   
            int ret = in_grouping_U(g_v, 97, 250, 1);
            if (ret < 0) goto lab1;
            c += ret;
        }
        I_p1 = c;
        {   
            int ret = out_grouping_U(g_v, 97, 250, 1);
            if (ret < 0) goto lab1;
            c += ret;
        }
        {   
            int ret = in_grouping_U(g_v, 97, 250, 1);
            if (ret < 0) goto lab1;
            c += ret;
        }
        I_p2 = c;
    lab1:
        c = c2;
    }
    return 1;
}

int Xapian::InternalStemIrish::r_initial_morph() {
    int among_var;
    bra = c;
    among_var = find_among(s_pool, a_0, 24, 0, 0);
    if (!(among_var)) return 0;
    ket = c;
    switch (among_var) {
        case 1:
            {   int ret = slice_del();
                if (ret < 0) return ret;
            }
            break;
        case 2:
            {   int ret = slice_from_s(1, s_0);
                if (ret < 0) return ret;
            }
            break;
        case 3:
            {   int ret = slice_from_s(1, s_1);
                if (ret < 0) return ret;
            }
            break;
        case 4:
            {   int ret = slice_from_s(1, s_2);
                if (ret < 0) return ret;
            }
            break;
        case 5:
            {   int ret = slice_from_s(1, s_3);
                if (ret < 0) return ret;
            }
            break;
        case 6:
            {   int ret = slice_from_s(1, s_4);
                if (ret < 0) return ret;
            }
            break;
        case 7:
            {   int ret = slice_from_s(1, s_5);
                if (ret < 0) return ret;
            }
            break;
        case 8:
            {   int ret = slice_from_s(1, s_6);
                if (ret < 0) return ret;
            }
            break;
        case 9:
            {   int ret = slice_from_s(1, s_7);
                if (ret < 0) return ret;
            }
            break;
        case 10:
            {   int ret = slice_from_s(1, s_8);
                if (ret < 0) return ret;
            }
            break;
    }
    return 1;
}

int Xapian::InternalStemIrish::r_RV() {
    if (!(I_pV <= c)) return 0;
    return 1;
}

int Xapian::InternalStemIrish::r_R1() {
    if (!(I_p1 <= c)) return 0;
    return 1;
}

int Xapian::InternalStemIrish::r_R2() {
    if (!(I_p2 <= c)) return 0;
    return 1;
}

int Xapian::InternalStemIrish::r_noun_sfx() {
    int among_var;
    ket = c;
    among_var = find_among_b(s_pool, a_1, 16, 0, 0);
    if (!(among_var)) return 0;
    bra = c;
    switch (among_var) {
        case 1:
            {   int ret = r_R1();
                if (ret <= 0) return ret;
            }
            {   int ret = slice_del();
                if (ret < 0) return ret;
            }
            break;
        case 2:
            {   int ret = r_R2();
                if (ret <= 0) return ret;
            }
            {   int ret = slice_del();
                if (ret < 0) return ret;
            }
            break;
    }
    return 1;
}

int Xapian::InternalStemIrish::r_deriv() {
    int among_var;
    ket = c;
    among_var = find_among_b(s_pool, a_2, 25, 0, 0);
    if (!(among_var)) return 0;
    bra = c;
    switch (among_var) {
        case 1:
            {   int ret = r_R2();
                if (ret <= 0) return ret;
            }
            {   int ret = slice_del();
                if (ret < 0) return ret;
            }
            break;
        case 2:
            {   int ret = slice_from_s(3, s_9);
                if (ret < 0) return ret;
            }
            break;
        case 3:
            {   int ret = slice_from_s(3, s_10);
                if (ret < 0) return ret;
            }
            break;
        case 4:
            {   int ret = slice_from_s(4, s_11);
                if (ret < 0) return ret;
            }
            break;
        case 5:
            {   int ret = slice_from_s(5, s_12);
                if (ret < 0) return ret;
            }
            break;
        case 6:
            {   int ret = slice_from_s(4, s_13);
                if (ret < 0) return ret;
            }
            break;
    }
    return 1;
}

int Xapian::InternalStemIrish::r_verb_sfx() {
    int among_var;
    ket = c;
    if (c - 2 <= lb || p[c - 1] >> 5 != 3 || !((282896 >> (p[c - 1] & 0x1f)) & 1)) return 0;
    among_var = find_among_b(s_pool, a_3, 12, 0, 0);
    if (!(among_var)) return 0;
    bra = c;
    switch (among_var) {
        case 1:
            {   int ret = r_RV();
                if (ret <= 0) return ret;
            }
            {   int ret = slice_del();
                if (ret < 0) return ret;
            }
            break;
        case 2:
            {   int ret = r_R1();
                if (ret <= 0) return ret;
            }
            {   int ret = slice_del();
                if (ret < 0) return ret;
            }
            break;
    }
    return 1;
}

int Xapian::InternalStemIrish::stem() {
    {   int c1 = c;
        {   int ret = r_initial_morph();
            if (ret < 0) return ret;
        }
        c = c1;
    }
    
    {   int ret = r_mark_regions();
        if (ret < 0) return ret;
    }
    lb = c; c = l;

    {   int m2 = l - c; (void)m2;
        {   int ret = r_noun_sfx();
            if (ret < 0) return ret;
        }
        c = l - m2;
    }
    {   int m3 = l - c; (void)m3;
        {   int ret = r_deriv();
            if (ret < 0) return ret;
        }
        c = l - m3;
    }
    {   int m4 = l - c; (void)m4;
        {   int ret = r_verb_sfx();
            if (ret < 0) return ret;
        }
        c = l - m4;
    }
    c = lb;
    return 1;
}

Xapian::InternalStemIrish::InternalStemIrish()
    : I_p2(0), I_p1(0), I_pV(0)
{
}

Xapian::InternalStemIrish::~InternalStemIrish()
{
}

std::string
Xapian::InternalStemIrish::get_description() const
{
    return "irish";
}
